# 02｜技术架构设计文档

本架构设计基于 Serverless 思维对 AI-CRM 系统进行整体规划，确保在 Vercel 等无服务器平台上保持高可用、低维护成本与良好的扩展性。

---

## 1. 全局架构概览

```
┌───────────────────────────────────────────────────────────────┐
│                         Vercel 平台                            │
│                                                               │
│  ┌──────────────────────┐   ┌─────────────────────────────┐  │
│  │ 静态资源托管 (app/)  │   │ Serverless Functions (api/) │  │
│  │  • HTML / CSS / JS    │   │  • 认证 / 客户 / 回访 / ... │  │
│  │  • CDN 全局加速      │   │  • Node.js 18 运行时         │  │
│  └──────────────────────┘   │  • Edge Middleware（可选）    │  │
│                              └──────────────┬────────────────┘│
│                                             │HTTP (JSON)       │
│                              ┌──────────────▼──────────────┐ │
│                              │ Vercel Postgres / Neon /     │ │
│                              │ Supabase（云数据库）          │ │
│                              │  • Prisma / Drizzle ORM      │ │
│                              │  • 自动扩缩容                │ │
│                              └──────────────┬──────────────┘ │
│                                             │SQL              │
│                              ┌──────────────▼──────────────┐ │
│                              │ Observability & Integrations │ │
│                              │  • Vercel Logs / Axiom       │ │
│                              │  • Sentry / Logtail（可选）   │ │
│                              │  • Cron Jobs (Vercel)        │ │
│                              └──────────────────────────────┘ │
└───────────────────────────────────────────────────────────────┘
```

---

## 2. 技术栈选型

| 层级 | 技术 | 说明 |
| --- | --- | --- |
| 前端 | 纯静态 HTML/CSS/JS（或升级至 Vite/React） | 无需服务器渲染，部署在 Vercel 静态资源层 |
| API 层 | Vercel Serverless Functions (Node.js 18) | 以 `api/*.ts` / `.js` 实现 RESTful 接口，按需拆分，每个函数独立部署 |
| 中间件 | 自定义中间件集合 | 通过轻量化适配器实现 Express 风格的请求处理、验证、错误捕捉 |
| 数据访问 | Prisma ORM / Drizzle ORM | 类型安全、易迁移；支持 `DATABASE_URL` 与 `DIRECT_URL` |
| 数据库 | Vercel Postgres（建议） | 支持自动扩缩容，零维护；也可选择 Neon / Supabase |
| 认证 | JWT + Edge Middleware（可选） | Access Token + Refresh Token；可于 Edge 进行快速校验 |
| 日志 | Vercel 内置日志 + Logtail/Axiom（可选） | 支持结构化 JSON 日志与可观测性 |
| 定时任务 | Vercel Cron Jobs | 用于每日备份、提醒计算等周期任务 |

---

## 3. Serverless Functions 模块划分

```
api/
├── auth/
│   ├── login.ts
│   ├── refresh.ts
│   └── logout.ts
├── customers/
│   ├── index.ts        # GET / POST
│   ├── [id].ts         # GET / PUT / DELETE
│   └── search.ts       # 可选：专用搜索接口
├── visits/
│   ├── index.ts
│   ├── [id].ts
│   └── statistics.ts   # 可选：汇总分析
├── products/
│   ├── index.ts
│   ├── [id].ts
│   └── statistics.ts
├── dashboard/
│   └── statistics.ts
├── presets/
│   ├── customer-categories.ts
│   ├── customer-intentions.ts
│   ├── regions.ts
│   ├── ...
│   └── reorder.ts       # 通用排序接口（根据 type 区分）
├── settings/
│   ├── index.ts
│   ├── dark-mode.ts
│   └── notification.ts
├── maintenance/
│   ├── backup.ts
│   ├── restore.ts
│   └── clear-data.ts
├── utils/
│   ├── http.ts         # 响应封装、错误处理
│   ├── middleware.ts   # Auth、RateLimit、Validation
│   ├── validator.ts    # Zod / Yup schema
│   └── logger.ts       # 统一日志
└── db/
    ├── client.ts       # Prisma 客户端单例
    ├── schema.prisma   # 数据模型定义
    └── seed.ts         # 种子数据脚本
```

- **单一职责**：每个 API 函数仅处理一类请求，避免冷启动时加载不必要的模块。
- **共享工具**：DB 客户端、验证工具、响应处理放置在公共模块，避免重复。
- **Edge Middleware**（可选）：在 `middleware.ts` 中拦截请求，实现 JWT 校验或 IP 白名单。

---

## 4. 数据访问层设计

### 4.1 ORM 模型（Prisma 示例）

```prisma
model Customer {
  id                     Int       @id @default(autoincrement())
  name                   String
  gender                 String?
  age                    String?
  birthday               DateTime?
  phone                  String?   @unique
  email                  String?   @unique
  address                String?
  company                String?
  position               String?
  avatarUrl              String?
  region                 String?
  registrationDate       DateTime?
  categoryId             String?
  intentionLevel         String?
  demand                 String?
  wechat                 String?
  whatsapp               String?
  facebook               String?
  budgetId               String?
  remark                 String?
  superiorContactId      Int?
  subordinateContactIds  String? // 以逗号分隔
  plannedVisitDate       DateTime?
  plannedVisitMethod     String?
  plannedVisitContent    String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  superiorContact        SuperiorContact? @relation(fields: [superiorContactId], references: [id])
  products               Product[]
  visits                 Visit[]
}

model Product {
  id            Int      @id @default(autoincrement())
  customerId    Int
  productName   String
  quantity      Int
  price         Decimal @db.Decimal(10, 2)
  purchaseDate  DateTime
  afterSale     String?
  followUpDate  DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  customer      Customer @relation(fields: [customerId], references: [id])
}
```

> 其余模型参照 `01_项目需求规格说明.md` 中的字段定义。确保为频繁查询字段建立索引（通过 Prisma `@@index` 或 Drizzle `index()`）。

### 4.2 连接管理
- 使用 Prisma Data Proxy 或 Vercel 提供的连接池 URL，避免 Serverless 冷启动导致的连接耗尽。
- 暴露 `getClient()` 工具函数，确保在每个请求中复用、释放连接。

```ts
import { PrismaClient } from '@prisma/client';

let prisma: PrismaClient;

export const getClient = () => {
  if (!prisma) {
    prisma = new PrismaClient({ log: ['warn', 'error'] });
  }
  return prisma;
};
```

---

## 5. 请求处理流程

### 5.1 典型 REST 请求

```
客户端请求
  ↓  (HTTP JSON)
Vercel Edge（可选：JWT 校验、限流）
  ↓
Serverless Function (api/customers/index.ts)
  ↓ 1) 解析请求方法
     2) 调用通用中间件（验证、鉴权、日志）
     3) 调用 Service 层处理业务逻辑
     4) 访问数据库（Prisma）并返回数据
  ↓
格式化响应 (utils/http -> jsonResponse)
  ↓
客户端接收并渲染
```

### 5.2 Service 层职责

- **Input Validation**：使用 Zod / Yup schema 对请求体、查询参数进行校验。
- **业务逻辑**：封装如“自动生成 followUpDate”、“提醒聚合”等逻辑，便于复用。
- **错误处理**：统一抛出 `HttpError(code, message)`，由响应层捕获并转换为 `{ error: message }`。

---

## 6. 安全与合规设计

| 方案 | 说明 |
| --- | --- |
| JWT 鉴权 | 登录后签发 Access Token（15 分钟）与 Refresh Token（7 天）；敏感接口需 Access Token |
| Rate Limit | 基于 Upstash Redis / Vercel Limiters，实现 IP + 路径限流 |
| 输入验证 | 所有写入接口使用 Zod Schema 校验；拒绝不合法字段 |
| SQL 防护 | ORM 自动参数化查询；禁止拼接 SQL |
| XSS & CSRF | 前端过滤用户输入；API 层返回 JSON；必要时设置 CORS 允许列表 |
| 安全头 | Edge Middleware 或 Response Headers 中添加 `Strict-Transport-Security`, `Content-Security-Policy` 等 |
| 密码加密 | 使用 bcrypt 或 argon2，在 Serverless Function 内进行哈希 |

---

## 7. 运维与可观测性

| 目标 | 技术手段 |
| --- | --- |
| 日志 | `utils/logger.ts` 输出结构化 JSON；Vercel Logs/Axiom 收集；关键操作（登录失败、删除数据）单独打点 |
| 指标 | 可选集成 Vercel Analytics 或自建指标上报（如 Prometheus Pushgateway + Cloudflare Workers） |
| 告警 | Vercel 自带状态通知；可配置到 Slack / 邮箱；严重错误（HTTP 5xx）触发告警 |
| 定时任务 | 使用 Vercel Cron 触发 `/api/maintenance/backup`、提醒预热等每日任务 |
| 备份策略 | 通过 `pg_dump` 或 ORM 脚本将数据导出到外部存储（S3/R2），至少每日一次 |

---

## 8. 代码组织与约束

- **模块分层**：`function -> handler -> service -> repository -> db`，其中 repository 与 service 可以合并为单层以维持轻量。
- **错误封装**：定义 `createError(status, message, details?)`，统一抛出。
- **响应封装**：
  ```ts
  return jsonResponse({ data }, { status: 200 });
  ```
- **中间件组合**：
  ```ts
  export default compose([
    withRateLimit({ requests: 100, window: 60 }),
    withAuth({ required: true }),
    withValidation(CustomerSchema)
  ])(async (req) => { ... });
  ```

---

## 9. 部署配置建议

`vercel.json` 示例如下：

```json
{
  "version": 2,
  "functions": {
    "api/**/*.ts": {
      "runtime": "nodejs18.x",
      "memory": 1024,
      "maxDuration": 10
    }
  },
  "redirects": [
    { "source": "/", "destination": "/app/index.html", "permanent": false }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" },
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        { "key": "X-Frame-Options", "value": "DENY" }
      ]
    }
  ]
}
```

---

## 10. 扩展方向

1. **前端 SPA 化**：使用 Next.js 或 Remix，将 Serverless API 与前端 UI 统一在同一框架内。
2. **多租户支持**：在数据表中增加 `tenantId` 字段，实现多组织隔离。
3. **事件驱动**：对于长耗时操作（导出、备份），可集成队列服务（如 Trigger.dev、QStash）。
4. **GraphQL 层**：基于 Yoga 等构建 GraphQL API，提升前端灵活性。
5. **AI 辅助功能**：集成 OpenAI/Claude API，实现自动生成回访话术、客户画像分析等能力。

---

本架构文档为 AI 或开发团队提供了清晰的模块划分、技术选型与部署指南，可直接作为实现 Serverless 版本的蓝图。
