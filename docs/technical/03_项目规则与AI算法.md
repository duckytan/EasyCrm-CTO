# 03｜项目规则与 AI 算法

本文档定义 AI-CRM 系统中的业务规则、数据验证标准、提醒聚合算法与仪表盘统计计算逻辑，为 AI 智能体生成准确的实现代码提供依据。

---

## 1. 数据验证规则

### 1.1 客户字段校验规则

| 字段 | 类型 | 必填 | 校验规则 | 示例 |
| --- | --- | --- | --- | --- |
| `name` | String | ✓ | 长度 1-100 字符 | "张三" |
| `phone` | String | ✗ | 正则：`^1[3-9]\d{9}$`（中国手机号） | "13800138000" |
| `email` | String | ✗ | 标准邮箱格式 | "zhangsan@example.com" |
| `birthday` | Date | ✗ | ISO 8601 格式，不能晚于今天 | "1990-01-01" |
| `age` | String | ✗ | 字符串形式的年龄范围，如 "25-30" | "25-30" |
| `gender` | String | ✗ | 枚举："男", "女", "其他" | "男" |
| `category` | String | ✗ | 引用 `CustomerCategories.id` | "vip" |
| `intention` | String | ✗ | 枚举："H", "A", "B", "C", "D" | "A" |
| `region` | String | ✗ | 引用 `Regions.id` | "华东" |
| `budget` | String | ✗ | 引用 `BudgetRanges.id` | "10000-50000" |
| `superiorContactId` | Integer | ✗ | 存在于 `SuperiorContacts` 表 | 1 |
| `subordinateContactIds` | String | ✗ | 逗号分隔的 ID 列表 | "2,3,5" |
| `planned_visit_date` | DateTime | ✗ | 不能早于今天 | "2024-06-01T10:00:00Z" |
| `planned_visit_method` | String | ✗ | 引用 `VisitMethods.name` | "电话回访" |

#### 校验伪代码（Zod 示例）

```typescript
import { z } from 'zod';

export const CustomerSchema = z.object({
  name: z.string().min(1).max(100),
  phone: z.string().regex(/^1[3-9]\d{9}$/).optional(),
  email: z.string().email().optional(),
  birthday: z.coerce.date()
    .max(new Date(), { message: "生日不能晚于今天" })
    .optional(),
  gender: z.enum(['男', '女', '其他']).optional(),
  category: z.string().optional(),
  intention: z.enum(['H', 'A', 'B', 'C', 'D']).optional(),
  superiorContactId: z.number().int().positive().optional(),
  subordinateContactIds: z.string().regex(/^\d+(,\d+)*$/).optional(),
  planned_visit_date: z.coerce.date().min(new Date(), {
    message: "计划回访日期不能早于今天"
  }).optional(),
});
```

---

### 1.2 回访记录校验规则

| 字段 | 类型 | 必填 | 校验规则 |
| --- | --- | --- | --- |
| `customerId` | Integer | ✓ | 必须存在于 `Customers` 表 |
| `visitTime` | DateTime | ✓ | ISO 8601 格式 |
| `content` | String | ✓ | 长度 1-500 字符 |
| `effect` | String | ✗ | 自由文本，建议枚举："优秀", "良好", "一般", "较差" |
| `satisfaction` | String | ✗ | 自由文本 |
| `intention` | String | ✗ | 枚举："H", "A", "B", "C", "D" |
| `followUp` | String | ✗ | 下一步跟进计划，长度 0-500 字符 |

#### 业务规则
- **意向更新**：如果回访记录中填写了 `intention`，则在创建后自动更新 `Customers.intention` 为最新值。
- **日期合理性**：`visitTime` 不应晚于当前时间超过 1 天（可选校验）。

---

### 1.3 产品订单校验规则

| 字段 | 类型 | 必填 | 校验规则 |
| --- | --- | --- | --- |
| `customerId` | Integer | ✓ | 必须存在于 `Customers` 表 |
| `productName` | String | ✓ | 长度 1-200 字符 |
| `quantity` | Integer | ✓ | > 0 |
| `price` | Decimal | ✓ | ≥ 0，最多两位小数 |
| `purchaseDate` | Date | ✓ | ISO 8601 格式，不能晚于今天 |
| `afterSale` | String | ✗ | 自由文本，描述售后服务条款 |
| `followUpDate` | Date | ✗ | 若未填写，自动设为 `purchaseDate + 90天` |

#### 业务规则
- **自动计算跟进日期**：
  ```typescript
  if (!followUpDate && purchaseDate) {
    const date = new Date(purchaseDate);
    date.setDate(date.getDate() + 90);
    followUpDate = date;
  }
  ```
- **总金额计算**：`totalAmount = quantity * price`（可选字段，便于统计）。

---

### 1.4 预设数据校验规则

通用规则：
- `name`：非空，长度 1-100。
- `displayOrder`：整数，≥ 0；默认为当前最大值 + 1。
- `id`（TEXT 主键表）：字母、数字、下划线组合，长度 1-50。

---

## 2. 提醒聚合算法

### 2.1 提醒来源

系统支持三种提醒类型，均从不同表的日期字段计算：

| 提醒类型 | 数据来源 | 判定字段 | 逻辑 |
| --- | --- | --- | --- |
| **计划回访** | Customers.planned_visit_date | `planned_visit_date` | 若日期在「今天 - 未来 N 天」内，则生成提醒 |
| **产品回访** | Products.followUpDate | `followUpDate` | 若日期在「今天 - 未来 N 天」内，则生成提醒 |
| **客户生日** | Customers.birthday | `birthday`（月-日） | 若生日月-日在「今天 - 未来 N 天」内，则生成提醒 |

> **N** 取值根据前端筛选条件决定（默认 30 天）。

---

### 2.2 算法伪代码

```typescript
interface Reminder {
  type: '计划回访' | '产品回访' | '客户生日';
  customerId: number;
  customerName: string;
  reminderDate: string; // YYYY-MM-DD
  content?: string;
  productName?: string;
}

async function getImportantReminders(daysAhead: number = 30): Promise<Reminder[]> {
  const today = new Date();
  const endDate = new Date(today);
  endDate.setDate(endDate.getDate() + daysAhead);

  const reminders: Reminder[] = [];

  // 1. 计划回访提醒
  const plannedVisits = await db.customer.findMany({
    where: {
      planned_visit_date: {
        gte: today,
        lte: endDate,
      },
    },
    select: { id, name, planned_visit_date, planned_visit_content },
  });
  reminders.push(...plannedVisits.map(c => ({
    type: '计划回访',
    customerId: c.id,
    customerName: c.name,
    reminderDate: c.planned_visit_date.toISOString().split('T')[0],
    content: c.planned_visit_content,
  })));

  // 2. 产品回访提醒
  const productsToFollowUp = await db.product.findMany({
    where: {
      followUpDate: {
        gte: today,
        lte: endDate,
      },
    },
    include: { customer: { select: { id, name } } },
  });
  reminders.push(...productsToFollowUp.map(p => ({
    type: '产品回访',
    customerId: p.customer.id,
    customerName: p.customer.name,
    reminderDate: p.followUpDate.toISOString().split('T')[0],
    productName: p.productName,
  })));

  // 3. 客户生日提醒
  const currentMonth = today.getMonth() + 1;
  const currentDay = today.getDate();
  const customersWithBirthdays = await db.customer.findMany({
    where: {
      birthday: { not: null },
    },
    select: { id, name, birthday },
  });

  customersWithBirthdays.forEach(c => {
    const birthdayThisYear = new Date(today.getFullYear(), c.birthday.getMonth(), c.birthday.getDate());
    if (birthdayThisYear >= today && birthdayThisYear <= endDate) {
      reminders.push({
        type: '客户生日',
        customerId: c.id,
        customerName: c.name,
        reminderDate: birthdayThisYear.toISOString().split('T')[0],
        content: `${c.name} 的生日`,
      });
    }
  });

  // 按 reminderDate 升序排序
  reminders.sort((a, b) => a.reminderDate.localeCompare(b.reminderDate));

  return reminders;
}
```

---

### 2.3 前端筛选建议

前端可提供提醒周期下拉菜单：
- 今天
- 3 天内
- 7 天内
- 15 天内
- 30 天内

选中后调用 `/api/dashboard/statistics?daysAhead=<days>` 获取对应提醒列表。

---

## 3. 仪表盘统计算法

### 3.1 统计指标定义

| 指标 | SQL 逻辑 | 数据源 |
| --- | --- | --- |
| **月度销售额** | `SUM(quantity * price)` WHERE `purchaseDate` 在本月 | Products |
| **月度订单数** | `COUNT(*)` WHERE `purchaseDate` 在本月 | Products |
| **平均订单金额** | `月度销售额 / 月度订单数` | 计算得出 |
| **月度新增客户** | `COUNT(*)` WHERE `created_at` 在本月 | Customers |
| **月度回访次数** | `COUNT(*)` WHERE `visitTime` 在本月 | Visits |
| **月度成交客户数** | `COUNT(DISTINCT customerId)` WHERE `purchaseDate` 在本月 | Products |
| **意向分布** | `GROUP BY intention` + `COUNT(*)` | Customers |

---

### 3.2 计算伪代码

```typescript
interface DashboardStatistics {
  monthlySalesAmount: number;
  monthlyOrderCount: number;
  averageOrderValue: number;
  monthlyNewCustomers: number;
  monthlyVisitCount: number;
  monthlyDealCustomers: number;
  intentionDistribution: Record<string, number>;
  importantReminders: Reminder[];
}

async function getDashboardStatistics(): Promise<DashboardStatistics> {
  const now = new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);

  // 月度销售额与订单数
  const products = await db.product.findMany({
    where: { purchaseDate: { gte: startOfMonth, lte: endOfMonth } },
    select: { quantity, price, customerId },
  });
  const monthlySalesAmount = products.reduce((sum, p) => sum + p.quantity * p.price, 0);
  const monthlyOrderCount = products.length;
  const averageOrderValue = monthlyOrderCount > 0 ? monthlySalesAmount / monthlyOrderCount : 0;

  // 月度新增客户
  const monthlyNewCustomers = await db.customer.count({
    where: { created_at: { gte: startOfMonth, lte: endOfMonth } },
  });

  // 月度回访次数
  const monthlyVisitCount = await db.visit.count({
    where: { visitTime: { gte: startOfMonth, lte: endOfMonth } },
  });

  // 月度成交客户数（去重）
  const uniqueCustomerIds = new Set(products.map(p => p.customerId));
  const monthlyDealCustomers = uniqueCustomerIds.size;

  // 意向分布
  const intentionGroups = await db.customer.groupBy({
    by: ['intention'],
    _count: { id: true },
  });
  const intentionDistribution = Object.fromEntries(
    intentionGroups.map(g => [g.intention || 'Unknown', g._count.id])
  );

  // 重要提醒
  const importantReminders = await getImportantReminders(30);

  return {
    monthlySalesAmount,
    monthlyOrderCount,
    averageOrderValue,
    monthlyNewCustomers,
    monthlyVisitCount,
    monthlyDealCustomers,
    intentionDistribution,
    importantReminders,
  };
}
```

---

## 4. 权限与访问控制

### 4.1 角色定义
当前系统仅支持单一角色：**管理员**（Admin），拥有所有功能权限。

### 4.2 访问令牌与刷新机制

- **Access Token**：有效期 15 分钟，用于所有需认证的 API 调用。
- **Refresh Token**：有效期 7 天，用于刷新 Access Token。
- **验证流程**：
  1. 客户端在请求头中携带 `Authorization: Bearer <token>`。
  2. Serverless Function 调用 `withAuth` 中间件，解析并验证 JWT。
  3. 若 token 过期，返回 401，客户端使用 Refresh Token 请求新 token。
  4. 若 Refresh Token 也过期，返回 401，提示重新登录。

#### Token 验证伪代码

```typescript
import jwt from 'jsonwebtoken';

function verifyAccessToken(token: string): { id: number; name: string } | null {
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET) as any;
    if (payload.type !== 'access') throw new Error('Invalid token type');
    return { id: payload.id, name: payload.name };
  } catch (err) {
    return null;
  }
}

function withAuth(handler) {
  return async (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: '未授权访问，请先登录' });
    }
    const token = authHeader.substring(7);
    const user = verifyAccessToken(token);
    if (!user) {
      return res.status(401).json({ error: '登录状态已失效，请重新登录' });
    }
    req.user = user;
    return handler(req, res);
  };
}
```

---

## 5. 速率限制规则

| 接口类别 | 限流规则 | 时间窗口 | 适用范围 |
| --- | --- | --- | --- |
| 全局 API | 100 req/min | 1 分钟 | 所有 `/api/*` |
| 登录接口 | 5 req/15min | 15 分钟 | `/api/auth/login` |
| 敏感操作 | 10 req/hour | 1 小时 | `/api/maintenance/*`, `/api/managers/change-password` |

#### 实现方案
- 使用 **Upstash Redis** 或 **Vercel KV** 存储请求计数。
- 以 `${ip}:${route}` 为 Key，记录时间窗口内的请求次数。
- 超过阈值返回 `429 Too Many Requests`。

---

## 6. 数据完整性与级联操作

### 6.1 级联删除规则

| 主表 | 关联表 | 级联行为 |
| --- | --- | --- |
| Customers | Products | 删除客户时，同时删除其所有订单 |
| Customers | Visits | 删除客户时，同时删除其所有回访记录 |
| SuperiorContacts | Customers | 删除上级联系人时，将关联客户的 `superiorContactId` 设为 NULL |

### 6.2 唯一性约束

- `Customers.phone`：同一手机号不能重复（若填写）。
- `Customers.email`：同一邮箱不能重复（若填写）。
- `Managers.name`：管理员用户名唯一。

---

## 7. 日志与审计规则

### 7.1 操作日志分级

| 级别 | 场景 | 示例 |
| --- | --- | --- |
| `info` | 正常业务操作 | 创建客户、更新订单 |
| `warn` | 异常但不影响服务 | 验证失败、限流触发 |
| `error` | 服务器错误 | 数据库连接失败、未捕获异常 |
| `debug` | 开发调试 | 打印请求体、SQL 语句 |

### 7.2 审计日志内容

关键操作需记录：
- 操作时间
- 操作用户（`user.id`）
- 操作类型（CREATE / UPDATE / DELETE）
- 操作对象（表名 + ID）
- 操作前后数据快照（可选）

---

## 8. 数据备份与恢复策略

### 8.1 备份频率
- **自动备份**：每日凌晨 2 点执行，通过 Vercel Cron 触发 `/api/maintenance/backup`。
- **手动备份**：用户可在前端「设置」页面点击备份按钮。

### 8.2 备份内容
- 全库数据（包括客户、回访、订单、预设数据、管理员账户）。
- 备份格式：SQL 文件（Postgres `pg_dump`）或 JSON。
- 存储位置：Vercel Blob / R2 / S3。

### 8.3 恢复流程
1. 列出所有备份文件，按时间戳降序排列。
2. 用户选择文件或默认恢复最新备份。
3. 清空当前数据（可选），执行 SQL 或 JSON 导入。
4. 记录恢复操作日志。

---

## 9. 排序与分页规则

### 9.1 分页参数
- `page`：页码，从 1 开始。
- `limit`：每页数量，默认 20，最大 100。

### 9.2 排序规则
- **列表接口默认排序**：按 `created_at DESC`（最新创建的在前）。
- **预设数据排序**：按 `displayOrder ASC`。
- **提醒列表排序**：按 `reminderDate ASC`（最早日期在前）。

---

本文档为 AI 提供了详尽的业务规则与算法实现指南，可直接转化为代码逻辑，确保系统行为的一致性与可预测性。
